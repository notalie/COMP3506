\documentclass[oneside, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[hypertexnames=false]{hyperref} 
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
}

\urlstyle{same}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{array}
\usepackage{soul}
\usepackage{amsmath}
\usepackage{forest}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


% Set spacing (i set it to 1.2x)
\renewcommand{\baselinestretch}{1}
% Indentation (set this to zero for normal prose)
\setlength{\parindent}{0em}
% Line breaking (spacing between paragraphs)
\setlength{\parskip}{0.5em}

% Use the whole page
\usepackage{geometry}
% Extra math glyphs
\usepackage{amsmath}
% Proper enumerate spacing
\usepackage{enumitem}
% More pleasing screen fonts
\usepackage{lmodern}
% Fancy headers
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{algpseudocode}
% Allows absolute positioning of images
\usepackage{float}
% \usepackage[section]{placeins}
% Set no separation
\setlist{noitemsep}
% Set margins to reasonable
\geometry{margin=2.5cm}
% Sets graphics path
\graphicspath{ {./images/} }
% Sets up fancy headers

\addto\captionsenglish{
}


\usepackage{listings}
\usepackage{color}

\pagestyle{plain}

\begin{document}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\pagestyle{fancy}
\fancyhf{}
\lhead{s4530974 - Homework Assignment 1}
\rhead{COMP3506}

\begin{titlepage}
\newgeometry{left=7.5cm} %defines the geometry for the titlepage
\noindent
\color{black}
\makebox[0pt][l]{\rule{1.3\textwidth}{1pt}}

{\Huge {Student - s4530974}}
\vskip\baselineskip
\noindent
{\huge{COMP3506 - Homework 1}}

\vskip\baselineskip
{\large {Semester 2 - 2020}}
\end{titlepage}

\newpage
\tableofcontents

\listoffigures

\newpage


\section*{Question 1}

\subsection*{1a - The Running Time of $T_{odd}$}
If n is odd then the if statement skips to this section of the function which then becomes $T_{odd}$. 

\
\begin{algorithmic}[1]
    \Function{$T_{odd}$}{int n}
    \State $sum \gets 0$ [1]
    \While {$n > 0$} [?? + 1]
        \State $sum \gets sum + (n \& 1)$ [3] 
        \State $n \gets (n >> 1)$ [2]
    \EndWhile
    \State \Return $sum$ [1]
    \EndFunction
\end{algorithmic}

\subsubsection*{Solving the ?? Part}
The running of the while loop part of the function is determined by the value of n and its most significant bit, you can assume that this bit would determine the times that the while loop would execute within $T_{odd}$. 

The function cannot be $O(n)$ as the amount of while loop iterations does not linearly increase as the number increases. As seen below with the first 9 inputs, going from 5 to 7 does not increase the amount of while loops iterations by a constant factor but is actually the same.

\input{while.tex}

Since the most significant bit is being used as an indicator of how many times the while loop executes, you can use a formula to find which power of 2 the most significant bit would lie on. This is done with the equation 


$$\ceil[\Bigg]{\frac{\log{(n)}}{\log(2)}}$$ 
Multiplying this equation by the amount of operations within the while loop and then adding 1 to the amount of iterations to account for the while loop check will give:

$$\ceil[\Bigg]{\frac{\log{(n)}}{\log(2)}} + 1$$ 

This equation was then multiplied by the number of primitive operations within the while loop which add up to be 5. This was then multiplied by the existing equation to give:

$$\ceil[\Bigg]{\frac{5\log{(n)}}{\log(2)}} + 5$$ 

You also have to account for the assigning of sum and returning of sum at the beginning as well as the if statement. This adds on 2 extra to the constant at the end resulting in the ending formula of:

$$\ceil[\Bigg]{\frac{5\log{(n)}}{\log(2)}} + 7$$ 

An assumption made was that the $n \& 1$ and $sum + (n \& 1)$ counted as 1 and 2 primitive operations each respectively which is why I counted the line with the assignment as 3.

\subsection*{1b - Finding a suitable function for $O(n)$}

A suitable function $g(n)$ that would fit $T_{odd}$ such that $g(n) \epsilon O(n)$. Since we know that the runtime function can be described as $\ceil[\Big]{\frac{5\log{(n)}}{\log(2)}} + 7$ we can start from there.

First, remove all constants and lower order terms which leaves us with $\frac{\log{n}}{\log(2)}$. 

Using the definition for $O(n)$ which is:
Given functions $f(n)$ and $g(n)$, we say that $f(n)$ is $O(g(n))$ if there are positive constants $c$ and $n_0$ such that 
$f(n) \leq c * g(n)$ for $n \geq n_0$

\begin{center}
    Suppose $g(n) = n, n_0 = 5, c = 3$

    Then $\frac{log(n)}{log(2)} \leq 3n$
    $$log(n) \leq 3n * log(2)$$
    $$log(n) \leq 3n * log(2), n = 5$$

    $log(5) \leq 3 * 5 * log(2)$ is true

    $\dot{.\hspace{.095in}.}\hspace{.5in} \frac{\log{n}}{\log(2)}$ is $O(n)$ when $n \geq 5, c = 3$
\end{center}

 
\subsection*{1c - Finding $\Omega$}
Using the definition for $O(n)$ which is:
Given functions $f(n)$ and $g(n)$, we say that $f(n)$ is $\Omega(g(n))$ if there are positive constants $c$ and $n_0$ such that $f(n) \geq c * g(n)$ for $n \geq n_0$

\begin{center}
    Suppose $g(n) = log(n), n_0 = 5, c = 3$

    Then $\frac{log(n)}{log(2)} \geq 3log(n)$
    $\frac{log(n)}{log(2)} \geq 3log(n)$

    Since $\frac{log(n)}{log(2)}$ is always $\geq 3log(n)$ 

    $\dot{.\hspace{.095in}.}\hspace{.5in} \frac{\log{n}}{\log(2)}$ is $\Omega(log(n))$ when $n \geq 5, c = 3$
\end{center}

In terms of $\Theta(n)$, I believe it does not exist as it only exists when Big-O == Big-Omega and $O(g(n)) \neq \Omega(g(n))$ so it does not exist.

\subsection*{1d - Bounds for $T_{even}$}

\begin{algorithmic}
    \Function{$T_{even}$}{int n}
    \For {$i = 0$ to n} [n + 1]
        \For {$j = i$ to $n^2$} [$n^2$]
            \State {$sum \gets sum + i + j$} [3]
        \EndFor
    \EndFor
    \State \Return $sum$
    \EndFunction
\end{algorithmic}

$T_{even}$

I am assuming that the condition for the for loop is $i \leq n$ 

The Upper Bound for $T_{even} \epsilon O(n^3)$ when $c = ??$ and $n_0 = ??$ 

The Lower Bound for $T_{even} \epsilon \Omega(n)$ when $c = ??$ and $n_0 = ??$ 

\subsection*{1e}
The best case for this algorithm would be if n = 1. The run time of this would be 

The worst case for this algorithm would be contained within $T_{even}$ and would be $O(n^3)$

\subsection*{1f}
\subsection*{1g}
My team mate is wrong as the best case does not define the bounds which are what Big-$\Omega$ and Big-$O$ are. A worst and best case scenario describe a singular scenario and are a singular point within the space of the algorithm where Big-$\Omega$ and Big-$O$ represent bound the lower and higher bounds respectively. They also define where worst and best cases can take place within the algorithm's asymptotic runtime.
\subsection*{1h - Some $\Theta(f(n))$ Proof}
Statement - $\Theta(g(n))$ only exists when $O(g(n)) = \Omega(g(n))$. 

This can be proved using the definition given as:
$f(n)$ is $\Theta(g(n))$ if there exist positive constants $c_1, c_2$ and $n_0$ such that $c_1 * g(n) \leq f(n) \leq c_2 * g(n)$ for all $n \geq n_0$

Since $O(g(n)) = \Omega(g(n))$, for $\Theta(f(n))$ to exist, it must be $g(n)$ otherwise the definition does not hold. 

Therefore $\Theta(f(n))$ is $\Theta(g(n))$ when $O(g(n)) = \Omega(g(n))$.

\newpage
\section*{Question 2}

\subsection*{2a}
\begin{algorithmic}
    \Function{FINDPOSITIONRECURSE}{A[n], int low, int high}
        \If{$high \geq low$}
            \State $mid \gets low + (high - low) / 2$
            \If{mid == A[mid]}
                \State \Return true    
            \EndIf
                
            \If{$mid < A[mid]$}
                \State \Return FINDPOSITIONRECURSE(A, low, (mid - 1))
            \Else
                \State \Return FINDPOSITIONRECURSE(A, (mid + 1), high)
            \EndIf

        \Else 
            \State \Return false    
        \EndIf
        
    \EndFunction
\end{algorithmic}
\
\
\begin{algorithmic}
    \Function{FINDPOSITION}{A[n]}
        \State return FINDPOSITIONRECURSE(A, 0, n - 1)
    \EndFunction
\end{algorithmic}


\subsection*{2b}
The steps taken within my function would take in the array and then call the recursive function FINDPOSITIONRECURSE low and high values set as 0 and n - 1 respecitvely. The function would then begin searching to see if $A[i] == i$. The recursion would be as follows:

\begin{itemize}
    \item -1 \textrightarrow the function would calculate and set mid as 4, it would then check if A[4] == 4, which it is not. It would then check if 4 < A[4], which it is. It would the enter recursion and pass in low as the same value but change high to be that of (mid - 1). 
    \item 0 \textrightarrow the function would calculate and set mid as 1, it would then check if A[1] == 1, which it is not. It would then check to see if 1 < A[1], which it is not. It would then enter recursion again and pass in high as the same value and change low to be that of (mid + 1). 
    \item 2 \textrightarrow the function would calculate and set mid as 2, it would then check to see if A[2] == 2, which it is. The function would then exit recursion and return true.
\end{itemize}

\subsection*{2c}
The worst case for my algorithm is where none of the values in A meet the conditions and the if high and low variables do not meet the requirements for the if statement $high \geq low$ and false is returned. The recurrence for this worse case would look like the following recurrence tree:

\input{tree.tex}

When put into a formula, the recurrence equation would look like the following:

\begin{equation}
    \begin{array}{l}
        T(n) = T(\frac{n}{2}) ... + 1\\\\
        T(n) = T(\frac{n}{2}) + T(\frac{n}{4}) + T(\frac{n}{8}) ... T(\frac{n}{2^k}) + 1
      \end{array}
\end{equation}

The constant is 1 because that is what is used for the return statement out of recursion. 

Since the tree eventually ends as $T(\frac{n}{2^k})$, you could break this function down to 

Since we know that $T(1) = 1$ as given by the base case. We can do the following:
$$\frac{n}{2^k} = 1$$
$$n = 2^k$$
$$k = log_2n$$

Therefore $O(g(n))$ of this algorithm is $O(log(n))$.

\subsection*{2d}

\subsubsection*{2di}
Since we know that $O(log(n))$ and that 

\begin{equation}
    T(n)=\begin{cases}
        T(\frac{n}{2^k}) + 1, & \text{if $n>1$}.\\
        1, & \text{$n = 1$}.
    \end{cases}
\end{equation}

With $a = 1, b = 2^k, c = 1, g(n) = 1$. 

Since $g(n) \epsilon \Theta(n^d), d = 0$

Using the Master Theorem, since $a = {2^k}^0 = 1$ then $T(n) = \Theta(log(n))$. The algorithm is therefore $\Theta(log(n))$. 

\subsubsection*{2dii}
\begin{center}
    $$T(n) = 5 * T (\frac{n}{3}) + n^2 + 2n$$

    Where $a = 5, b = 3, g(n) = n^2 + 2n$

    Since $g(n) \epsilon \Theta(n^d)$ 

    Then $g(n) \epsilon \Theta(n^2)$ and $d = 2$

    Sicne $5 < 3^2$, the $\Theta$ bounds for $T(n)$ is $\Theta(n^2)$ where 2 is d for when $T(1) = 100$.
\end{center}


\subsubsection*{2diii}
Since n = k, the $\Theta$ is  $\Theta(1)$ for when $T(1) = 1$.

\subsection*{2e}
\begin{algorithmic}
    \Function{FINDPOSITION}{A[n]}
        \State $low \gets 0$
        \State $high \gets (n - 1)$

        \While{$high \geq low$}

            \State $mid \gets low + (high - low) / 2$
            \If{mid == A[mid]}
                \State \Return true    
            \EndIf
                
            \If{$mid < A[mid]$}
                \State $high \gets (mid + 1)$
            \Else
                \State $low \gets (mid - 1)$
            \EndIf

        \EndWhile
        \State \Return false    
        
    \EndFunction
\end{algorithmic}

The runtime complexity of my second solution is within $O(log(n))$ time. This is because while there is no recursion within my program, it is still a binary search implementation which works by splitting search size by 2 which eventually 

\subsection*{2f}
I believe that the better function to run within Java will be my iterative one. This is because if there are more elements within A, there runs the risk of getting a Stack Overflow during the program, which is very much unwanted. 

In terms of space complexity, I believe that 


\section*{Question 3}
\section*{Question 4}
\subsection*{4a}
\subsection*{4b}

Returns a true if the drilled plot is a water source and false if it is not.
\begin{algorithmic}[1]
    \Function{IsWaterSource}{G[n], int x, int y}
    \State \Return boolean isSource
    \EndFunction
\end{algorithmic}

\
Returns a char relating to the source direction ('N', 'E', 'S', 'W')
\begin{algorithmic}[1]
    \Function{GetSourceDirection}{G[n], int x, int y}
    \State \Return char direction
    \EndFunction
\end{algorithmic}

\
\begin{algorithmic}[1]
    \Function{FindWaterSourceMinimal}{G[n]}
    \State

    \EndFunction
\end{algorithmic}

\end{document}